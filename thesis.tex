% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[shortabstract, english]{iithesis}

\usepackage[utf8]{inputenc}
\usepackage{enumitem}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle {Inicjalizacja i zarządzanie \fmlinebreak pamięcią wirtualną
  \fmlinebreak w systemie operacyjnym FreeBSD}

\englishtitle {Virtual Memory \fmlinebreak Initialization and Management
  \fmlinebreak in the FreeBSD Operating System}

\polishabstract {
  Pamięć wirtualna jest jedną z najważniejszych abstrakcji udostępnianych
  programom użytkownika przez jądra nowoczesnych systemów operacyjnych.
  Znacznie upraszcza ona budowanie aplikacji, jednak efektywna jej implementacja
  stanowi duże wyzwanie. Jądro systemu operacyjnego FreeBSD jest przykładem
  efektywnej implementacji pamięci wirtualnej. Niestety, osiągnięcie dobrej
  wydajności wymaga zastosowania złożonych struktur danych i algorytmów, co
  sprawia że osobom niezaznajomionym z jądrem trudno jest zrozumieć działanie
  podsystemu pamięci wirtualnej. \ldots
}

\englishabstract {
  Virtual memory is one of the most important abstractions
  provided to user space programs by modern operating system kernels. While it
  greatly simplifies application development, implementing it efficiently is a
  great challenge. The FreeBSD operating system kernel VM (Virtual Memory)
  subsystem succeeds at this goal. However, in doing so it employs complex data
  structures and algorithms, which make it difficult to understand for newcomers
  to the kernel. This thesis provides an overview of the architecture of the
  FreeBSD VM subsystem, along with fragments of real-world (albeit simplified)
  source code that implement its most important functions. Subsequently, it goes
  through the initialization of the VM subsystem on the x86 architecture. It
  also acts as a guide to reading the kernel's source code.
}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Jakub Piecuch}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr Piotr Witkowski}
%\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
\transcriptnum {281940}                     % Numer indeksu
\advisorgen    {dr. Piotra Witkowskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
\usepackage{amsfonts}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

\input macros
\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY


\chapter*{Przykłady komentarzy do tekstu}

\pwit{Komentarz w treści} \pwitside{Komentarz na boku}
\cahir{Komentarz w treści} \cahirside{Komentarz na boku}
\response{Odpowiedź na komentarz w treści} \responseside{Odpowiedź na
  komentarz na boku}

\pwit{Dodałem makra umożliwiające komentowanie i odpowiedź na
  komentarze. Wymagało to dodania wiersza do do iithesis.cls, ale nie
  powinno mieć to wpływu na układ tekstu. Po napisaniu i
  zaakceptowaniu pracy można te zmiany usunąć.}


\chapter{Introduction}


\section{What is virtual memory?}

A system implementing virtual memory provides every process in the system with
an address space of its own, its \textbf{Virtual Address Space} (VAS). The
modifications that a process makes to its own VAS are not visible to other
processes, unless they explicitly choose to share fragments of their address
spaces. This protects running programs against unwanted interference.

The size of the VAS can (and typically is on 64 bit architectures) much larger
than the amount of available \textbf{physical memory}, i.e. memory actually
installed in the system. For instance, the VAS size on the AMD64 architecture is
$2^{48}$ bytes, that is 256 TiB (tebibytes)\footnote{
  1 TiB = 1024 GiB (gibibytes). A gibibyte is slightly larger than a gigabyte. \\
  See \url{https://en.wikipedia.org/wiki/Binary_prefix}.}.

The VAS of any process contains the whole \textbf{process image}, that is the
instructions, data and the run-time stack. A process in execution accesses
memory to fetch its instructions, as well as to read and write data. All
instructions executed by the process access memory using \textbf{Virtual
  Addresses} (VAs), which are integers in the range from 0 to $N-1$, where $N$
is the VAS size.

Since the VAS size can be larger than the amount of available physical memory,
there cannot be a 1-to-1 correspondence between VAs and \textbf{Physical
  Addresses} (PAs), which refer directly to locations in physical memory. It is
necessary to allow either VAs which have no corresponding PAs, or multiple VAs
with the same corresponding PA. To accomplish this, a scheme called
\textbf{address translation} is used.

Modern architectures provide hardware support for address translation in the
form of a \textbf{Memory Management Unit} (MMU). The MMU translates VAs
generated by the program into PAs used to address the physical memory. As the
details are architecture-specific, this thesis focuses on the x86 architecture.

In the x86 architecture, the mapping between VAs and PAs is determined by an
in-memory data structure called a \textbf{Page Table} (PT). The VAS is divided
into units called \textbf{pages}. Their size is usually 4 KiB. Likewise, the
physical memory is divided into page-sized units called \textbf{page frames}.
The Page Table describes the mapping between pages and page frames, instead of
between individual virtual addresses and physical addresses. This significantly
reduces the size of the Page Table.

In addition to specifying the mapping between pages and page frames, the Page
Table also determines the protection attributes of each page. For instance,
pages containing program code can be marked read-only, e.g. so that a malicious
user can't exploit a bug in the program to overwrite the original instructions
with malicious ones.

Not every page needs to be mapped to a page frame. Whenever the program
references an address which is in a page that is not mapped, a \textbf{page
  fault} occurs. The MMU detects this and the CPU generates an exception.
Execution then jumps to a routine provided by the OS, which handles the
exception. The same is done when the programs tries to do something to a page
that violates the page's protection attributes, e.g. write to a read-only page.

An important observation is that with virtual memory, processes can be partially
\textbf{resident} in physical memory (i.e. only parts of their image have to be
in physical memory). Unused pages can be unmapped, as an exception will
generated only when a process references the page. Furthermore, even pages that
are used by a process don't have to be resident at all times, as the OS can map
them into the VAS in response to a page fault, and then restart the
instruction that caused it. This strategy is called \textbf{demand paging} and
is widely used. It enables the system to use memory resources efficiently
by holding only as many mapped pages in physical memory as are necessary for
any one process to run smoothly.

In summary, virtual memory has the following important characteristics:
\begin{itemize}
\item The address spaces in which processes live are isolated from one another
\item A process may run even if the total amount of memory it requires is larger
  than the total amount of available physical memory
\item A process can have its memory pages mapped into its address space on
  demand, and unmapped when the OS determines the process is unlikely to
  reference them in the near future
\end{itemize}

\section{The FreeBSD Operating System}

FreeBSD is an open-source operating system, first released in 1993. It is the
most popular OS in the BSD family of Operating Systems, which includes FreeBSD,
NetBSD, OpenBSD and DragonFlyBSD. Unlike Linux, FreeBSD is a whole Operating
System, providing the kernel, drivers and a suite of utility programs.

It is released under a permissive BSD license, which makes it an attractive
choice for commercial applications. FreeBSD has been used as the basis for
Operating Systems such as Apple's MacOS, as well as the OS running on Sony's
PlayStation 3 and PlayStation 4 consoles.

\subsection{Browsing the source code}

This thesis includes many source code listings from the FreeBSD repository.
Because of its scope, the level of implementation detail covered is limited.
Should the reader want to explore the source tree themselves (which is strongly
encouraged), there are several websites providing the code of the whole FreeBSD
kernel with support for identifier search:
\begin{enumerate}[label=\textnormal{(\arabic*)}]
\item \url{http://fxr.watson.org/}\label{fxr}
\item \url{http://bxr.su/}\label{bxr}
\end{enumerate}

The author recommends \ref{fxr}, as it allows the user to select any major
version of the source tree, while \ref{bxr} only presents the latest revision.
This is especially relevant since all source code discussion and listings apply
specifically to the \texttt{11-STABLE} version of the kernel. On the other hand,
\ref{bxr} has a more aesthetically pleasing interface, which includes syntax
highlighting.

The kernel source code can be found in the \texttt{/sys} directory of the tree.
Since other parts of the tree are not going to be discussed, all subsequent
paths are relative to this directory.

The \texttt{kern} directory holds most of the kernel's portable code, like the
scheduler, subsystem initialization and shutdown, and the Virtual File System.

The \texttt{vm} directory contains the machine-independent part of the Virtual
Memory subsystem. This is where most of the code listings will come from.
Machine-dependent parts of the subsystem can be found in the directories named
after a particular architecture, e.g. the \texttt{i386} directory for the x86
architecture. This is quite confusing, since the kernel source tree contains a
directory named \texttt{x86} -- this directory contains architecture-specific
code that is shared between the AMD64 and x86 architectures.

%%%%% BIBLIOGRAFIA

% \begin{thebibliography}{1}
% \bibitem{example} \ldots
% \end{thebibliography}

\end{document}
